# Here we will create a mono-repo that will have both the backend API and the frontend in React.
# The mono-repo idea is interesting because it shares common dependencies and allow front and backend to share types and some common definitions.

pnpm init   # this creates a package.json

pnpm create vite@latest web  # the name of the project is 'web'

# in this command select the options:
◇  Select a framework:
│  React
│
◇  Select a variant:
│  TypeScript
│
◇  Use rolldown-vite (Experimental)?:
│  No
│
◇  Install with pnpm and start now?
│  Yes


# After this initial setup, I cleaned the 'web' project, removing some stuff we're not going to use.
# Then, go to 'web' folder and run:
pnpm i
# so that we update the dependencies we we manually changed in the package.json



# Now, we'll focus on the backend
# Create a folder api/ and inside it run:
pnpm init

# We'll create this backend from scratch (manually). Here we'll use tsx because it has some nice features
# that the typescript support from ndoe does not include yet, such as aliases for relative imports with @ symbol.
pnpm i typescript @types/node tsx -D

# Now we create a config for typescript:
pnpm tsc --init

# Check out the version of node we have installed
node --version

# Then go to this webside
https://github.com/tsconfig/bases

# and choose the corresponding node version you got. You can either install the package, or
# you can just copy the content of your created tsconfig.json with theirs.

# The only thing we are going to include in this tsconfig.json is to add an alias to make
# our imports simpler. Inside the compilerOptions add the following:
"paths": {
  "@/*": ["./src/*"]
}


# Now, setup Biome, a library to format out code (like prettier)
pnpm add -D -E @biomejs/biome

pnpm exec biome init

# I added some custom configurations to biome.json and also included a script on package.json to run biome format


# Now, let's work on the routes. For this, we need to install a few libs:

pnpm i @fastify/cors @fastify/swagger zod fastify-type-provider-zod @scalar/fastify-api-reference

- cors is used for
- swagger will automatically generate a documentation for our API
- zod will validatate the requests
- fastify-type-provider-zod allows a serialization of every route, i.e. the route is called only if the user pass the data in the exact format it is expected. It also brings type inference.
- scalar is a nice open-source UI that can be used along with swagger, but it creates a better visualization.


# Now, we create a simple connection to a Postgres database.
# I'll not use volumes in the docker-compose file to make it easier to clean the database (do not persist after reinit)

docker compose up -D

# To access the DB, we will use Drizzle, which is an ORM (like Prisma, TypeORM, Hibernate, Eloquent, etc),
# but it's syntax is very close to the traditional SQL. So we can still use a 'pure' SQL syntax while also
# having nice features such as migrations, type inference, and schema manegement. So, let's install the dependencies

pnpm i drizzle-kit -D
pnpm i drizzle-orm drizzle-zod pg
pnpm i @types/pg -D

# Just a note about the schema for the webhook table: we are using UUID for the id field. However, in this application, we
# want to have an infinite scroll feature which shows the webhooks sorted by timestamp. OK, so what? The thing is that
# the UUID that comes by default with node (v4) or the one that comes with Postgres are not time sortable.
# Here, we want to use the UUID v7 because we can time sort the registers (data) in our database based on its creation.

pnpm i uuidv7

# To make sure the connection with the DB is working, we created a few scripts in package.json. Now, we run them as:

pnpm run db:generate  # read schemas and generate the SQL to create the tables or modify them
pnpm run db:migrate  # run the migrations (create or modify tables)
pnpm run db:studio  # a drizzle feature that creates an URL to visualize the DB


----------------------


Now let's focus on the frontend (web application).

We'll use Tanstack Router which serves as a router for the front end, like a ReactRouterDOM. However, Tanstack Router
is bringing in a few more nice features, so that is why will'll choose it.

pnpm add @tanstack/react-router @tanstack/react-router-devtools
pnpm add -D @tanstack/router-plugin

We'll also use Tailwind CSS

pnpm i tailwindcss @tailwindcss/vite

Let's also install BiomeJS to fix some linting issues.

pnpm add -D -E @biomejs/biome
pnpm exec biome init
